package cn.zqtao.code.leetcode.sort;

import java.util.Arrays;

/**
 * @auther: zqtao
 * @description: 冒泡排序
 * 原理：比较两个相邻的元素，将值大的元素交换至右端。
 * <p>
 * 思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。
 * 即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
 * 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
 * 直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。
 *<p>
 *
 * 举例说明：要排序数组：int[] arr={6,3,8,2,9,1};
 *
 * 第一趟排序：
 *
 * 　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1
 *
 * 　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1
 *
 * 　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1
 *
 * 　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1
 *
 * 　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9
 *
 * 　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9
 *
 * ---------------------------------------------------------------------
 *
 * 第二趟排序：
 *
 * 　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9
 *
 * 　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9
 *
 * 　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9
 *
 * 　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9
 *
 * 　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 第三趟排序：
 *
 * 　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9
 *
 * 　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9
 *
 * 　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9
 *
 * 　　　　第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 第四趟排序：
 *
 * 　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9
 *
 * 　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9
 *
 * 　　　　第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 第五趟排序：
 *
 * 　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9
 *
 * 　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * 最终结果：1  2  3  6  8  9
 *
 * ---------------------------------------------------------------------
 *
 * <p>
 * 由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-1-i)次，
 * 所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即
 *
 * 复制代码
 * for(int i=0;i<arr.length-1;i++){
 *
 *     for(int j=0;j<arr.length-1-i;j++){
 *
 *     //交换位置
 *
 * }
 * 冒泡排序的优点：
 * <P></P>
 *      每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。
 *      如上例：
 *      第一趟比较之后，排在最后的一个数一定是最大的一个数，
 *      第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，
 *      同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只
 *      需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，
 *      一定程度上减少了算法的量
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {6, 3, 8, 2, 9, 1};
        System.out.println(Arrays.toString(bubbleSort(arr)));
    }

    /**
     * 时间复杂度
     * 最好的情况下只需要一趟比较 o(n)
     * 最坏的情况下 o(n^2)
     */
    public static int[] bubbleSort(int[] arr){
        // 外层循环控制排序趟数
        for (int i = 0; i < arr.length - 1; i++) {
            // 内层循环控制每趟比较次数, 每趟总会找到一个最大值放在应该存在的位置，所以比较第j趟比较次数要减去 i(趟，一趟少比较一个)
            for (int j = 0; j < (arr.length - 1) - i; j++) {
                if (arr[j] > arr[j + 1])
                    swap(arr, j, j+1);
            }
        }
        return arr;
    }

    public static void swap(int[] arr, int a, int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
